{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n/** Append flags */\n\n/** Extract flags */\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\n\nclass Masked {\n  /** */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n  constructor(opts) {\n    this._value = '';\n\n    this._update({ ...Masked.DEFAULTS,\n      ...opts\n    });\n\n    this._initialized = true;\n  }\n  /** Sets and applies new options */\n\n\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n  /** Sets new options */\n\n\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n  /** Mask state */\n\n\n  get state() {\n    return {\n      _value: this.value,\n      _rawInputValue: this.rawInputValue\n    };\n  }\n\n  set state(state) {\n    this._value = state._value;\n  }\n  /** Resets value */\n\n\n  reset() {\n    this._value = '';\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n  /** Resolve new value */\n\n\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n\n  get unmaskedValue() {\n    return this.value;\n  }\n\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n  /** Value that includes raw user input */\n\n\n  get rawInputValue() {\n    return this.extractInput(0, this.displayValue.length, {\n      raw: true\n    });\n  }\n\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n\n  get displayValue() {\n    return this.value;\n  }\n\n  get isComplete() {\n    return true;\n  }\n\n  get isFilled() {\n    return this.isComplete;\n  }\n  /** Finds nearest input position in direction */\n\n\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    return Math.min(this.displayValue.length, toPos - fromPos);\n  }\n  /** Extracts value in range considering flags */\n\n\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    return this.displayValue.slice(fromPos, toPos);\n  }\n  /** Extracts tail in range */\n\n\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n  /** Appends tail */\n\n\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n  /** Appends char */\n\n\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n  /** Appends char */\n\n\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.displayValue.length - details.tailShift);\n        }\n\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString(); // not ok, try shift\n\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        } // if ok, rollback state after tail\n\n\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      } // revert all if something went wrong\n\n\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n\n    return details;\n  }\n  /** Appends optional placeholder at the end */\n\n\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n  /** Appends optional eager placeholder at the end */\n\n\n  _appendEager() {\n    return new ChangeDetails();\n  }\n  /** Appends symbols considering flags */\n\n\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    } // append tail but aggregate only tailShift\n\n\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift; // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    return details;\n  }\n\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\n    return new ChangeDetails();\n  }\n  /** Calls function and reapplies current value */\n\n\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput; // append lost trailing chars at the end\n\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.displayValue.length), {}, '');\n    }\n\n    delete this._refreshing;\n    return ret;\n  }\n\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n  /** Prepares string before mask processing */\n\n\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n  /** Prepares each char before mask processing */\n\n\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n  /** Validates if value is acceptable */\n\n\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n  /** Does additional processing at the end of editing */\n\n\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n\n    let startChangePos = start;\n    const details = new ChangeDetails(); // if it is just deletion without insertion\n\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection); // adjust tailShift if start was aligned\n\n      details.tailShift = startChangePos - start;\n    }\n\n    details.aggregate(this.remove(startChangePos));\n\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n\n        while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\n  }\n\n}\n\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["ChangeDetails","ContinuousTailDetails","isString","DIRECTION","forceDirection","IMask","Masked","constructor","opts","_value","_update","DEFAULTS","_initialized","updateOptions","Object","keys","length","withValueRefresh","bind","assign","state","value","_rawInputValue","rawInputValue","reset","resolve","input","flags","append","doCommit","unmaskedValue","typedValue","parse","format","String","extractInput","displayValue","raw","isComplete","isFilled","nearestInputPos","cursorPos","direction","totalInputPositions","fromPos","toPos","Math","min","slice","extractTail","appendTail","tail","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","checkTail","consistentState","details","doPrepareChar","aggregate","consistentTail","appended","doValidate","beforeTailState","overwrite","unshift","tailShift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","doPrepare","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","indexOf","runIsolated","_isolated","Boolean","skipInvalid","normalize","prepare","prepareChar","validate","parent","commit","splice","start","deleteCount","removeDirection","NONE","tailPos","eagerRemove","oldRawValue","startChangePos","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","typedValueEquals","tval","EMPTY_VALUES","includes","undefined","default"],"sources":["/home/eduardo/Repositorios/desafio-junior-1/petshop-front-end/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Append flags */\n\n/** Extract flags */\n\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\nclass Masked {\n  /** */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    this._value = '';\n    this._update({\n      ...Masked.DEFAULTS,\n      ...opts\n    });\n    this._initialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!Object.keys(opts).length) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /** Sets new options */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value,\n      _rawInputValue: this.rawInputValue\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n\n  /** Resolve new value */\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.displayValue.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n  get displayValue() {\n    return this.value;\n  }\n  get isComplete() {\n    return true;\n  }\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return Math.min(this.displayValue.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return this.displayValue.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    details = details.aggregate(this._appendCharRaw(ch, flags));\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          checkTail.unshift(this.displayValue.length - details.tailShift);\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted === checkTail.toString();\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          checkTail.shift();\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted === checkTail.toString();\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at the end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at the end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n\n    return details;\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at the end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.displayValue.length), {}, '');\n    }\n    delete this._refreshing;\n    return ret;\n  }\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n\n  /** Prepares string before mask processing */\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n\n  /** Prepares each char before mask processing */\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n\n  /** Validates if value is acceptable */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /** Does additional processing at the end of editing */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\n  }\n}\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}