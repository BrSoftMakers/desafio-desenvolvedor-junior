{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n/** Pattern mask */\n\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n  constructor(opts) {\n    super({ ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n    super._update(opts);\n\n    this._rebuildMask();\n  }\n\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0); // order by key length\n\n        bNames.sort((a, b) => b.length - a.length); // use block name with max length\n\n        const bName = bNames[0];\n\n        if (bName) {\n          const {\n            expose,\n            ...blockOpts\n          } = normalizeOpts(this.blocks[bName]);\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...blockOpts,\n            parent: this\n          });\n\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            if (expose) this.exposeBlock = maskedBlock; // store block index\n\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n\n          i += bName.length - 1;\n          continue;\n        }\n      }\n\n      let char = pattern[i];\n      let isInput = (char in defs);\n\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n\n        continue;\n      }\n\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n\n      this._blocks.push(def);\n    }\n  }\n\n  get state() {\n    return { ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n\n    super.state = maskedState;\n  }\n\n  reset() {\n    super.reset();\n\n    this._blocks.forEach(b => b.reset());\n  }\n\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n\n    super.doCommit();\n  }\n\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value : // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  _appendEager() {\n    var _this$_mapPosToBlock;\n\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details; // TODO test if it works for nested pattern masks\n\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n\n    return details;\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta;\n\n      const block = this._blocks[bi];\n      if (!block) break;\n\n      const blockDetails = block._appendChar(ch, { ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n\n    return chunkTail;\n  }\n\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    if (fromPos === toPos) return '';\n    let input = '';\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n\n    return input;\n  }\n\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n\n    return stopBefore;\n  }\n  /** Appends placeholder depending on laziness */\n\n\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n\n    return details;\n  }\n  /** Finds block in pos */\n\n\n  _mapPosToBlock(pos) {\n    let accVal = '';\n\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        } // process last block\n\n\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    const removeDetails = super.remove(fromPos, toPos);\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n\n    return removeDetails;\n  }\n\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    } // FORCE is only about a|* otherwise is 0\n\n\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      } // forward flow\n\n\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled(); // backward flow\n\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length; // backward flow\n\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n\n    return cursorPos;\n  }\n\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    let total = 0;\n\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n\n    return total;\n  }\n  /** Get block by name */\n\n\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n  /** Get all blocks by name */\n\n\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n\n}\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["ChangeDetails","IMask","DIRECTION","Masked","createMask","normalizeOpts","ChunksTailDetails","PatternCursor","PatternFixedDefinition","PatternInputDefinition","MaskedPattern","constructor","opts","DEFAULTS","definitions","Object","assign","DEFAULT_DEFINITIONS","updateOptions","_update","_rebuildMask","defs","_blocks","exposeBlock","undefined","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","length","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","expose","blockOpts","maskedBlock","lazy","eager","placeholderChar","displayChar","overwrite","parent","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","tail","extractTail","_blockStartPos","displayValue","appendTail","value","typedValue","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","blockIndex","extend","extractInput","input","_","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","_blocks2","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["/home/eduardo/Repositorios/desafio-junior-1/petshop-front-end/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/** Pattern mask */\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const {\n            expose,\n            ...blockOpts\n          } = normalizeOpts(this.blocks[bName]);\n          const maskedBlock = createMask({\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            ...blockOpts,\n            parent: this\n          });\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n            if (expose) this.exposeBlock = maskedBlock;\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value :\n    // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}