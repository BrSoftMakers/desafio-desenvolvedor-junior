{"ast":null,"code":"import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n/** Dynamic mask for choosing appropriate mask in run-time */\n\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n  constructor(opts) {\n    super({ ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = undefined;\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n\n  _update(opts) {\n    super._update(opts);\n\n    if ('mask' in opts) {\n      this.exposeMask = undefined; // mask could be totally dynamic with only `dispatch` option\n\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const {\n          expose,\n          ...maskOpts\n        } = normalizeOpts(m);\n        const masked = createMask({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid,\n          ...maskOpts\n        });\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : []; // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    const details = this._applyDispatch(ch, flags);\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n\n    return details;\n  }\n\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    if (tail === void 0) {\n      tail = '';\n    }\n\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state; // clone flags to prevent overwriting `_beforeTailState`\n\n    this.currentMask = this.doDispatch(appended, { ...flags\n    }, tail); // restore state after dispatch\n\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n\n        if (insertValue) {\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n\n    return details;\n  }\n\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n\n    return details;\n  }\n\n  _appendEager() {\n    const details = this._applyDispatch();\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n\n    return details;\n  }\n\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n\n    return { ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    if (tail === void 0) {\n      tail = '';\n    }\n\n    return this.dispatch(appended, this, flags, tail);\n  }\n\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    let [s, details] = super.doPrepare(str, flags);\n\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n\n    return [s, details];\n  }\n\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    let [s, details] = super.doPrepareChar(str, flags);\n\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n\n    return [s, details];\n  }\n\n  reset() {\n    var _this$currentMask;\n\n    (_this$currentMask = this.currentMask) == null ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n\n      this._applyDispatch();\n    } else super.value = value;\n  }\n\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n\n      this._applyDispatch();\n\n      return;\n    }\n\n    let unmaskedValue = String(typedValue); // double check it\n\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n\n    this.unmaskedValue = unmaskedValue;\n  }\n\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  get isComplete() {\n    var _this$currentMask2;\n\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  get isFilled() {\n    var _this$currentMask3;\n\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos)) // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n\n    return details;\n  }\n\n  get state() {\n    var _this$currentMask4;\n\n    return { ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n\n    super.state = maskedState;\n  }\n\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n\n  set eager(eager) {\n    this._eager = eager;\n  }\n\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n\n  typedValueEquals(value) {\n    var _this$currentMask5;\n\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n\n}\n\nMaskedDynamic.DEFAULTS = void 0;\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue; // simulate input\n\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    }); // pop masks with longer values first\n\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["DIRECTION","objectIncludes","ChangeDetails","createMask","normalizeOpts","Masked","IMask","MaskedDynamic","constructor","opts","DEFAULTS","currentMask","undefined","updateOptions","_update","exposeMask","compiledMasks","Array","isArray","mask","map","m","expose","maskOpts","masked","overwrite","_overwrite","eager","_eager","skipInvalid","_skipInvalid","_appendCharRaw","ch","flags","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","length","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","doPrepareChar","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","fromPos","toPos","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","cursorPos","direction","maskEquals","every","oldMask","restOpts","typedValueEquals","_this$currentMask5","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["C:/Users/lucas/OneDrive/Área de Trabalho/petshop-front-end/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = undefined;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      this.exposeMask = undefined;\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const {\n          expose,\n          ...maskOpts\n        } = normalizeOpts(m);\n        const masked = createMask({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid,\n          ...maskOpts\n        });\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.value = value;\n  }\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n      return;\n    }\n    let unmaskedValue = String(typedValue);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n  set eager(eager) {\n    this._eager = eager;\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = void 0;\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}