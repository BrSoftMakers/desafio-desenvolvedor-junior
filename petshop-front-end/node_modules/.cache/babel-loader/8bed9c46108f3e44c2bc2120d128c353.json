{"ast":null,"code":"import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n/** Number mask */\n\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n  constructor(opts) {\n    super({ ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n\n  _update(opts) {\n    super._update(opts);\n\n    this._updateRegExps();\n  }\n\n  _updateRegExps() {\n    const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    const mid = '\\\\d*';\n    const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\n    if (ch && !prepCh) details.skip = true;\n    if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\n    return [prepCh, details];\n  }\n\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n\n    let count = 0;\n\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n\n    return count;\n  }\n\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n\n    this._value = this._removeThousandsSeparators(this.value);\n\n    const appendDetails = super._appendCharRaw(ch, flags);\n\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n\n    return -1;\n  }\n\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n\n    const separatorAroundToPos = this._findSeparatorAround(to);\n\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n\n          break;\n        }\n\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n\n    return cursorPos;\n  }\n\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && ( // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && ( // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n\n    return valid && super.doValidate(flags);\n  }\n\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number; // check bounds\n\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n\n    super.doCommit();\n  }\n\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix); // remove leading zeros\n\n\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num); // add leading zero\n\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n  /** Parsed Number */\n\n\n  get number() {\n    return this.typedValue;\n  }\n\n  set number(number) {\n    this.typedValue = number;\n  }\n  /**\n    Is negative allowed\n  */\n\n\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n  /**\n    Is positive allowed\n  */\n\n\n  get allowPositive() {\n    return this.min != null && this.min > 0 || this.max != null && this.max > 0;\n  }\n\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n\n}\n\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\nexport { MaskedNumber as default };","map":{"version":3,"names":["escapeRegExp","DIRECTION","ChangeDetails","Masked","IMask","MaskedNumber","constructor","opts","DEFAULTS","updateOptions","_update","_updateRegExps","start","allowNegative","mid","end","scale","radix","_numberRegExp","RegExp","_mapToRadixRegExp","mapToRadix","map","join","_thousandsSeparatorRegExp","thousandsSeparator","_removeThousandsSeparators","value","replace","_insertThousandsSeparators","parts","split","doPrepareChar","ch","flags","prepCh","details","length","input","raw","skip","allowPositive","aggregate","_appendChar","_separatorsCount","to","extendOnSeparators","count","pos","_value","indexOf","_separatorsCountFromSlice","slice","extractInput","fromPos","toPos","displayValue","_adjustRangeWithSeparators","_appendCharRaw","prevBeforeTailValue","tail","_beforeTailState","prevBeforeTailSeparatorsCount","appendDetails","beforeTailValue","beforeTailSeparatorsCount","tailShift","rawInserted","_findSeparatorAround","searchFrom","separatorPos","from","separatorAroundFromPos","separatorAroundToPos","remove","valueBeforePos","valueAfterPos","nearestInputPos","cursorPos","direction","NONE","LEFT","FORCE_LEFT","separatorAtLeftPos","separatorAtLeftEndPos","RIGHT","FORCE_RIGHT","separatorAtRightPos","doValidate","valid","Boolean","match","number","isNaN","min","max","doCommit","validnum","Math","unmaskedValue","format","formatted","normalizeZeros","_normalizeZeros","padFractionalZeros","_padFractionalZeros","sign","zeros","num","test","push","padEnd","doSkipInvalid","checkTail","dropFractional","UNMASKED_RADIX","includes","typedValue","parse","n","rawInputValue","typedValueEquals","EMPTY_VALUES","mask","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","toLocaleString","useGrouping","maximumFractionDigits","default"],"sources":["C:/Users/lucas/OneDrive/Área de Trabalho/petshop-front-end/node_modules/imask/esm/masked/number.js"],"sourcesContent":["import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Number mask */\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    super({\n      ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n  _updateRegExps() {\n    const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    const mid = '\\\\d*';\n    const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\n    if (ch && !prepCh) details.skip = true;\n    if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\n    return [prepCh, details];\n  }\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const appendDetails = super._appendCharRaw(ch, flags);\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && (\n      // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && (\n      // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n    return valid && super.doValidate(flags);\n  }\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n\n  /**\n    Is negative allowed\n  */\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n\n  /**\n    Is positive allowed\n  */\n  get allowPositive() {\n    return this.min != null && this.min > 0 || this.max != null && this.max > 0;\n  }\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\n\nexport { MaskedNumber as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}