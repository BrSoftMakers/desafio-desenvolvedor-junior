{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport { isString } from '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n/** Date mask */\n\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n  constructor(opts) {\n    const {\n      mask,\n      pattern,\n      ...patternOpts\n    } = { ...MaskedDate.DEFAULTS,\n      ...opts\n    };\n    super({ ...patternOpts,\n      mask: isString(mask) ? mask : pattern\n    });\n  }\n\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n\n  _update(opts) {\n    const {\n      mask,\n      pattern,\n      blocks,\n      ...patternOpts\n    } = { ...MaskedDate.DEFAULTS,\n      ...opts\n    };\n    const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS()); // adjust year block\n\n    if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\n    if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\n\n    if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\n      patternBlocks.m.from = opts.min.getMonth() + 1;\n      patternBlocks.m.to = opts.max.getMonth() + 1;\n\n      if (patternBlocks.m.from === patternBlocks.m.to) {\n        patternBlocks.d.from = opts.min.getDate();\n        patternBlocks.d.to = opts.max.getDate();\n      }\n    }\n\n    Object.assign(patternBlocks, this.blocks, blocks); // add autofix\n\n    Object.keys(patternBlocks).forEach(bk => {\n      const b = patternBlocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n\n    super._update({ ...patternOpts,\n      mask: isString(mask) ? mask : pattern,\n      blocks: patternBlocks\n    });\n  }\n\n  doValidate(flags) {\n    const date = this.date;\n    return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n  /** Checks if date is exists */\n\n\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n  /** Parsed Date */\n\n\n  get date() {\n    return this.typedValue;\n  }\n\n  set date(date) {\n    this.typedValue = date;\n  }\n\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n\n}\n\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\n\nMaskedDate.DEFAULTS = {\n  mask: Date,\n  pattern: 'd{.}`m{.}`Y',\n  format: (date, masked) => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: (str, masked) => {\n    const [day, month, year] = str.split('.').map(Number);\n    return new Date(year, month - 1, day);\n  }\n};\nIMask.MaskedDate = MaskedDate;\nexport { MaskedDate as default };","map":{"version":3,"names":["MaskedPattern","MaskedRange","IMask","isString","MaskedDate","constructor","opts","mask","pattern","patternOpts","DEFAULTS","updateOptions","_update","blocks","patternBlocks","Object","assign","GET_DEFAULT_BLOCKS","min","Y","from","getFullYear","max","to","m","getMonth","d","getDate","keys","forEach","bk","b","autofix","doValidate","flags","date","isComplete","isDateExist","value","str","format","parse","indexOf","typedValue","maskEquals","Date","maxLength","masked","day","String","padStart","month","year","join","split","map","Number","default"],"sources":["/home/eduardo/Repositorios/desafio-junior-1/petshop-front-end/node_modules/imask/esm/masked/date.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport { isString } from '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    const {\n      mask,\n      pattern,\n      ...patternOpts\n    } = {\n      ...MaskedDate.DEFAULTS,\n      ...opts\n    };\n    super({\n      ...patternOpts,\n      mask: isString(mask) ? mask : pattern\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      mask,\n      pattern,\n      blocks,\n      ...patternOpts\n    } = {\n      ...MaskedDate.DEFAULTS,\n      ...opts\n    };\n    const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();\n    if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {\n      patternBlocks.m.from = opts.min.getMonth() + 1;\n      patternBlocks.m.to = opts.max.getMonth() + 1;\n      if (patternBlocks.m.from === patternBlocks.m.to) {\n        patternBlocks.d.from = opts.min.getDate();\n        patternBlocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(patternBlocks, this.blocks, blocks);\n\n    // add autofix\n    Object.keys(patternBlocks).forEach(bk => {\n      const b = patternBlocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n    super._update({\n      ...patternOpts,\n      mask: isString(mask) ? mask : pattern,\n      blocks: patternBlocks\n    });\n  }\n  doValidate(flags) {\n    const date = this.date;\n    return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n}\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nMaskedDate.DEFAULTS = {\n  mask: Date,\n  pattern: 'd{.}`m{.}`Y',\n  format: (date, masked) => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: (str, masked) => {\n    const [day, month, year] = str.split('.').map(Number);\n    return new Date(year, month - 1, day);\n  }\n};\nIMask.MaskedDate = MaskedDate;\n\nexport { MaskedDate as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}