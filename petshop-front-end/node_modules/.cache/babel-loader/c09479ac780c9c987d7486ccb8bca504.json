{"ast":null,"code":"import { DIRECTION } from '../../core/utils.js';\n\nclass PatternCursor {\n  constructor(masked, pos) {\n    this.masked = masked;\n    this._log = [];\n    const {\n      offset,\n      index\n    } = masked._mapPosToBlock(pos) || (pos < 0 ? // first\n    {\n      index: 0,\n      offset: 0\n    } : // last\n    {\n      index: this.masked._blocks.length,\n      offset: 0\n    });\n    this.offset = offset;\n    this.index = index;\n    this.ok = false;\n  }\n\n  get block() {\n    return this.masked._blocks[this.index];\n  }\n\n  get pos() {\n    return this.masked._blockStartPos(this.index) + this.offset;\n  }\n\n  get state() {\n    return {\n      index: this.index,\n      offset: this.offset,\n      ok: this.ok\n    };\n  }\n\n  set state(s) {\n    Object.assign(this, s);\n  }\n\n  pushState() {\n    this._log.push(this.state);\n  }\n\n  popState() {\n    const s = this._log.pop();\n\n    if (s) this.state = s;\n    return s;\n  }\n\n  bindBlock() {\n    if (this.block) return;\n\n    if (this.index < 0) {\n      this.index = 0;\n      this.offset = 0;\n    }\n\n    if (this.index >= this.masked._blocks.length) {\n      this.index = this.masked._blocks.length - 1;\n      this.offset = this.block.displayValue.length; // TODO this is stupid type error, `block` depends on index that was changed above\n    }\n  }\n\n  _pushLeft(fn) {\n    this.pushState();\n\n    for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) == null ? void 0 : _this$block.displayValue.length) || 0) {\n      var _this$block;\n\n      if (fn()) return this.ok = true;\n    }\n\n    return this.ok = false;\n  }\n\n  _pushRight(fn) {\n    this.pushState();\n\n    for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {\n      if (fn()) return this.ok = true;\n    }\n\n    return this.ok = false;\n  }\n\n  pushLeftBeforeFilled() {\n    return this._pushLeft(() => {\n      if (this.block.isFixed || !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);\n      if (this.offset !== 0) return true;\n    });\n  }\n\n  pushLeftBeforeInput() {\n    // cases:\n    // filled input: 00|\n    // optional empty input: 00[]|\n    // nested block: XX<[]>|\n    return this._pushLeft(() => {\n      if (this.block.isFixed) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n      return true;\n    });\n  }\n\n  pushLeftBeforeRequired() {\n    return this._pushLeft(() => {\n      if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n      return true;\n    });\n  }\n\n  pushRightBeforeFilled() {\n    return this._pushRight(() => {\n      if (this.block.isFixed || !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);\n      if (this.offset !== this.block.value.length) return true;\n    });\n  }\n\n  pushRightBeforeInput() {\n    return this._pushRight(() => {\n      if (this.block.isFixed) return; // const o = this.offset;\n\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE); // HACK cases like (STILL DOES NOT WORK FOR NESTED)\n      // aa|X\n      // aa<X|[]>X_    - this will not work\n      // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;\n\n      return true;\n    });\n  }\n\n  pushRightBeforeRequired() {\n    return this._pushRight(() => {\n      if (this.block.isFixed || this.block.isOptional && !this.block.value) return; // TODO check |[*]XX_\n\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\n      return true;\n    });\n  }\n\n}\n\nexport { PatternCursor as default };","map":{"version":3,"names":["DIRECTION","PatternCursor","constructor","masked","pos","_log","offset","index","_mapPosToBlock","_blocks","length","ok","block","_blockStartPos","state","s","Object","assign","pushState","push","popState","pop","bindBlock","displayValue","_pushLeft","fn","_this$block","_pushRight","pushLeftBeforeFilled","isFixed","value","nearestInputPos","FORCE_LEFT","pushLeftBeforeInput","LEFT","pushLeftBeforeRequired","isOptional","pushRightBeforeFilled","FORCE_RIGHT","pushRightBeforeInput","NONE","pushRightBeforeRequired","default"],"sources":["/home/eduardo/Repositorios/desafio-junior-1/petshop-front-end/node_modules/imask/esm/masked/pattern/cursor.js"],"sourcesContent":["import { DIRECTION } from '../../core/utils.js';\n\nclass PatternCursor {\n  constructor(masked, pos) {\n    this.masked = masked;\n    this._log = [];\n    const {\n      offset,\n      index\n    } = masked._mapPosToBlock(pos) || (pos < 0 ?\n    // first\n    {\n      index: 0,\n      offset: 0\n    } :\n    // last\n    {\n      index: this.masked._blocks.length,\n      offset: 0\n    });\n    this.offset = offset;\n    this.index = index;\n    this.ok = false;\n  }\n  get block() {\n    return this.masked._blocks[this.index];\n  }\n  get pos() {\n    return this.masked._blockStartPos(this.index) + this.offset;\n  }\n  get state() {\n    return {\n      index: this.index,\n      offset: this.offset,\n      ok: this.ok\n    };\n  }\n  set state(s) {\n    Object.assign(this, s);\n  }\n  pushState() {\n    this._log.push(this.state);\n  }\n  popState() {\n    const s = this._log.pop();\n    if (s) this.state = s;\n    return s;\n  }\n  bindBlock() {\n    if (this.block) return;\n    if (this.index < 0) {\n      this.index = 0;\n      this.offset = 0;\n    }\n    if (this.index >= this.masked._blocks.length) {\n      this.index = this.masked._blocks.length - 1;\n      this.offset = this.block.displayValue.length; // TODO this is stupid type error, `block` depends on index that was changed above\n    }\n  }\n\n  _pushLeft(fn) {\n    this.pushState();\n    for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) == null ? void 0 : _this$block.displayValue.length) || 0) {\n      var _this$block;\n      if (fn()) return this.ok = true;\n    }\n    return this.ok = false;\n  }\n  _pushRight(fn) {\n    this.pushState();\n    for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) {\n      if (fn()) return this.ok = true;\n    }\n    return this.ok = false;\n  }\n  pushLeftBeforeFilled() {\n    return this._pushLeft(() => {\n      if (this.block.isFixed || !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);\n      if (this.offset !== 0) return true;\n    });\n  }\n  pushLeftBeforeInput() {\n    // cases:\n    // filled input: 00|\n    // optional empty input: 00[]|\n    // nested block: XX<[]>|\n    return this._pushLeft(() => {\n      if (this.block.isFixed) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n      return true;\n    });\n  }\n  pushLeftBeforeRequired() {\n    return this._pushLeft(() => {\n      if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);\n      return true;\n    });\n  }\n  pushRightBeforeFilled() {\n    return this._pushRight(() => {\n      if (this.block.isFixed || !this.block.value) return;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);\n      if (this.offset !== this.block.value.length) return true;\n    });\n  }\n  pushRightBeforeInput() {\n    return this._pushRight(() => {\n      if (this.block.isFixed) return;\n\n      // const o = this.offset;\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\n      // HACK cases like (STILL DOES NOT WORK FOR NESTED)\n      // aa|X\n      // aa<X|[]>X_    - this will not work\n      // if (o && o === this.offset && this.block instanceof PatternInputDefinition) continue;\n      return true;\n    });\n  }\n  pushRightBeforeRequired() {\n    return this._pushRight(() => {\n      if (this.block.isFixed || this.block.isOptional && !this.block.value) return;\n\n      // TODO check |[*]XX_\n      this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);\n      return true;\n    });\n  }\n}\n\nexport { PatternCursor as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}